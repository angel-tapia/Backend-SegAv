"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_6HJSACPK_exports = {};
__export(chunk_6HJSACPK_exports, {
  getPackedPackage: () => getPackedPackage,
  require_p_map: () => require_p_map
});
module.exports = __toCommonJS(chunk_6HJSACPK_exports);
var import_chunk_TCKAZCW5 = require("./chunk-TCKAZCW5.js");
var import_chunk_HM4TYOFK = require("./chunk-HM4TYOFK.js");
var import_chunk_FGKIPLS5 = require("./chunk-FGKIPLS5.js");
var import_chunk_IQB47LU2 = require("./chunk-IQB47LU2.js");
var import_chunk_VWHCET2H = require("./chunk-VWHCET2H.js");
var import_chunk_W4B2MEEJ = require("./chunk-W4B2MEEJ.js");
var import_chunk_MFGQSSGY = require("./chunk-MFGQSSGY.js");
var import_chunk_6FFJQ4TS = require("./chunk-6FFJQ4TS.js");
var import_chunk_OQQ4P4PG = require("./chunk-OQQ4P4PG.js");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var require_lib = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/npm-normalize-package-bin@2.0.0/node_modules/npm-normalize-package-bin/lib/index.js"(exports, module2) {
    "use strict";
    var { join, basename } = (0, import_chunk_OQQ4P4PG.__require)("path");
    var normalize = (pkg) => !pkg.bin ? removeBin(pkg) : typeof pkg.bin === "string" ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : typeof pkg.bin === "object" ? normalizeObject(pkg) : removeBin(pkg);
    var normalizeString = (pkg) => {
      if (!pkg.name) {
        return removeBin(pkg);
      }
      pkg.bin = { [pkg.name]: pkg.bin };
      return normalizeObject(pkg);
    };
    var normalizeArray = (pkg) => {
      pkg.bin = pkg.bin.reduce((acc, k) => {
        acc[basename(k)] = k;
        return acc;
      }, {});
      return normalizeObject(pkg);
    };
    var removeBin = (pkg) => {
      delete pkg.bin;
      return pkg;
    };
    var normalizeObject = (pkg) => {
      const orig = pkg.bin;
      const clean = {};
      let hasBins = false;
      Object.keys(orig).forEach((binKey) => {
        const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).slice(1);
        if (typeof orig[binKey] !== "string" || !base) {
          return;
        }
        const binTarget = join("/", orig[binKey]).replace(/\\/g, "/").slice(1);
        if (!binTarget) {
          return;
        }
        clean[base] = binTarget;
        hasBins = true;
      });
      if (hasBins) {
        pkg.bin = clean;
      } else {
        delete pkg.bin;
      }
      return pkg;
    };
    module2.exports = normalize;
  }
});
var require_lib2 = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/npm-bundled@2.0.1/node_modules/npm-bundled/lib/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_OQQ4P4PG.__require)("fs");
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    var EE = (0, import_chunk_OQQ4P4PG.__require)("events").EventEmitter;
    var normalizePackageBin = require_lib();
    var BundleWalker = class _BundleWalker extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.path = path2.resolve(opt.path || process.cwd());
        this.parent = opt.parent || null;
        if (this.parent) {
          this.result = this.parent.result;
          if (!this.parent.parent) {
            const base = path2.basename(this.path);
            const scope = path2.basename(path2.dirname(this.path));
            this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
          }
          this.root = this.parent.root;
          this.packageJsonCache = this.parent.packageJsonCache;
        } else {
          this.result = /* @__PURE__ */ new Set();
          this.root = this.path;
          this.packageJsonCache = opt.packageJsonCache || /* @__PURE__ */ new Map();
        }
        this.seen = /* @__PURE__ */ new Set();
        this.didDone = false;
        this.children = 0;
        this.node_modules = [];
        this.package = null;
        this.bundle = null;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "done" && this.didDone) {
          this.emit("done", this.result);
        }
        return ret;
      }
      done() {
        if (!this.didDone) {
          this.didDone = true;
          if (!this.parent) {
            const res = Array.from(this.result);
            this.result = res;
            this.emit("done", res);
          } else {
            this.emit("done");
          }
        }
      }
      start() {
        const pj = path2.resolve(this.path, "package.json");
        if (this.packageJsonCache.has(pj)) {
          this.onPackage(this.packageJsonCache.get(pj));
        } else {
          this.readPackageJson(pj);
        }
        return this;
      }
      readPackageJson(pj) {
        fs2.readFile(pj, (er, data) => er ? this.done() : this.onPackageJson(pj, data));
      }
      onPackageJson(pj, data) {
        try {
          this.package = normalizePackageBin(JSON.parse(data + ""));
        } catch (er) {
          return this.done();
        }
        this.packageJsonCache.set(pj, this.package);
        this.onPackage(this.package);
      }
      allDepsBundled(pkg) {
        return Object.keys(pkg.dependencies || {}).concat(
          Object.keys(pkg.optionalDependencies || {})
        );
      }
      onPackage(pkg) {
        const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [];
        const bd = Array.from(new Set(
          Array.isArray(bdRaw) ? bdRaw : bdRaw === true ? this.allDepsBundled(pkg) : Object.keys(bdRaw)
        ));
        if (!bd.length) {
          return this.done();
        }
        this.bundle = bd;
        this.readModules();
      }
      readModules() {
        readdirNodeModules(this.path + "/node_modules", (er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm));
      }
      onReaddir(nm) {
        this.node_modules = nm;
        this.bundle.forEach((dep) => this.childDep(dep));
        if (this.children === 0) {
          this.done();
        }
      }
      childDep(dep) {
        if (this.node_modules.indexOf(dep) !== -1) {
          if (!this.seen.has(dep)) {
            this.seen.add(dep);
            this.child(dep);
          }
        } else if (this.parent) {
          this.parent.childDep(dep);
        }
      }
      child(dep) {
        const p = this.path + "/node_modules/" + dep;
        this.children += 1;
        const child = new _BundleWalker({
          path: p,
          parent: this
        });
        child.on("done", (_) => {
          if (--this.children === 0) {
            this.done();
          }
        });
        child.start();
      }
    };
    var BundleWalkerSync = class _BundleWalkerSync extends BundleWalker {
      start() {
        super.start();
        this.done();
        return this;
      }
      readPackageJson(pj) {
        try {
          this.onPackageJson(pj, fs2.readFileSync(pj));
        } catch {
        }
        return this;
      }
      readModules() {
        try {
          this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
        } catch {
          this.onReaddir([]);
        }
      }
      child(dep) {
        new _BundleWalkerSync({
          path: this.path + "/node_modules/" + dep,
          parent: this
        }).start();
      }
    };
    var readdirNodeModules = (nm, cb) => {
      fs2.readdir(nm, (er, set) => {
        if (er) {
          cb(er);
        } else {
          const scopes = set.filter((f) => /^@/.test(f));
          if (!scopes.length) {
            cb(null, set);
          } else {
            const unscoped = set.filter((f) => !/^@/.test(f));
            let count = scopes.length;
            scopes.forEach((scope) => {
              fs2.readdir(nm + "/" + scope, (readdirEr, pkgs) => {
                if (readdirEr || !pkgs.length) {
                  unscoped.push(scope);
                } else {
                  unscoped.push.apply(unscoped, pkgs.map((p) => scope + "/" + p));
                }
                if (--count === 0) {
                  cb(null, unscoped);
                }
              });
            });
          }
        }
      });
    };
    var readdirNodeModulesSync = (nm) => {
      const set = fs2.readdirSync(nm);
      const unscoped = set.filter((f) => !/^@/.test(f));
      const scopes = set.filter((f) => /^@/.test(f)).map((scope) => {
        try {
          const pkgs = fs2.readdirSync(nm + "/" + scope);
          return pkgs.length ? pkgs.map((p) => scope + "/" + p) : [scope];
        } catch (er) {
          return [scope];
        }
      }).reduce((a, b) => a.concat(b), []);
      return unscoped.concat(scopes);
    };
    var walk = (options, callback) => {
      const p = new Promise((resolve, reject) => {
        new BundleWalker(options).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (options) => {
      return new BundleWalkerSync(options).start().result;
    };
    module2.exports = walk;
    walk.sync = walkSync;
    walk.BundleWalker = BundleWalker;
    walk.BundleWalkerSync = BundleWalkerSync;
  }
});
var require_lib3 = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/ignore-walk@5.0.1/node_modules/ignore-walk/lib/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_OQQ4P4PG.__require)("fs");
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    var EE = (0, import_chunk_OQQ4P4PG.__require)("events").EventEmitter;
    var Minimatch = (0, import_chunk_W4B2MEEJ.require_minimatch)().Minimatch;
    var Walker = class _Walker extends EE {
      constructor(opts) {
        opts = opts || {};
        super(opts);
        this.isSymbolicLink = opts.isSymbolicLink;
        this.path = opts.path || process.cwd();
        this.basename = path2.basename(this.path);
        this.ignoreFiles = opts.ignoreFiles || [".ignore"];
        this.ignoreRules = {};
        this.parent = opts.parent || null;
        this.includeEmpty = !!opts.includeEmpty;
        this.root = this.parent ? this.parent.root : this.path;
        this.follow = !!opts.follow;
        this.result = this.parent ? this.parent.result : /* @__PURE__ */ new Set();
        this.entries = null;
        this.sawError = false;
      }
      sort(a, b) {
        return a.localeCompare(b, "en");
      }
      emit(ev, data) {
        let ret = false;
        if (!(this.sawError && ev === "error")) {
          if (ev === "error") {
            this.sawError = true;
          } else if (ev === "done" && !this.parent) {
            data = Array.from(data).map((e) => /^@/.test(e) ? `./${e}` : e).sort(this.sort);
            this.result = data;
          }
          if (ev === "error" && this.parent) {
            ret = this.parent.emit("error", data);
          } else {
            ret = super.emit(ev, data);
          }
        }
        return ret;
      }
      start() {
        fs2.readdir(this.path, (er, entries) => er ? this.emit("error", er) : this.onReaddir(entries));
        return this;
      }
      isIgnoreFile(e) {
        return e !== "." && e !== ".." && this.ignoreFiles.indexOf(e) !== -1;
      }
      onReaddir(entries) {
        this.entries = entries;
        if (entries.length === 0) {
          if (this.includeEmpty) {
            this.result.add(this.path.slice(this.root.length + 1));
          }
          this.emit("done", this.result);
        } else {
          const hasIg = this.entries.some((e) => this.isIgnoreFile(e));
          if (hasIg) {
            this.addIgnoreFiles();
          } else {
            this.filterEntries();
          }
        }
      }
      addIgnoreFiles() {
        const newIg = this.entries.filter((e) => this.isIgnoreFile(e));
        let igCount = newIg.length;
        const then = (_) => {
          if (--igCount === 0) {
            this.filterEntries();
          }
        };
        newIg.forEach((e) => this.addIgnoreFile(e, then));
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        fs2.readFile(ig, "utf8", (er, data) => er ? this.emit("error", er) : this.onReadIgnoreFile(file, data, then));
      }
      onReadIgnoreFile(file, data, then) {
        const mmopt = {
          matchBase: true,
          dot: true,
          flipNegate: true,
          nocase: true
        };
        const rules = data.split(/\r?\n/).filter((line) => !/^#|^$/.test(line.trim())).map((rule) => {
          return new Minimatch(rule.trim(), mmopt);
        });
        this.ignoreRules[file] = rules;
        then();
      }
      filterEntries() {
        const filtered = this.entries.map((entry) => {
          const passFile = this.filterEntry(entry);
          const passDir = this.filterEntry(entry, true);
          return passFile || passDir ? [entry, passFile, passDir] : false;
        }).filter((e) => e);
        let entryCount = filtered.length;
        if (entryCount === 0) {
          this.emit("done", this.result);
        } else {
          const then = (_) => {
            if (--entryCount === 0) {
              this.emit("done", this.result);
            }
          };
          filtered.forEach((filt) => {
            const entry = filt[0];
            const file = filt[1];
            const dir = filt[2];
            this.stat({ entry, file, dir }, then);
          });
        }
      }
      onstat({ st, entry, file, dir, isSymbolicLink }, then) {
        const abs = this.path + "/" + entry;
        if (!st.isDirectory()) {
          if (file) {
            this.result.add(abs.slice(this.root.length + 1));
          }
          then();
        } else {
          if (dir) {
            this.walker(entry, { isSymbolicLink }, then);
          } else {
            then();
          }
        }
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        fs2.lstat(abs, (lstatErr, lstatResult) => {
          if (lstatErr) {
            this.emit("error", lstatErr);
          } else {
            const isSymbolicLink = lstatResult.isSymbolicLink();
            if (this.follow && isSymbolicLink) {
              fs2.stat(abs, (statErr, statResult) => {
                if (statErr) {
                  this.emit("error", statErr);
                } else {
                  this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then);
                }
              });
            } else {
              this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then);
            }
          }
        });
      }
      walkerOpt(entry, opts) {
        return {
          path: this.path + "/" + entry,
          parent: this,
          ignoreFiles: this.ignoreFiles,
          follow: this.follow,
          includeEmpty: this.includeEmpty,
          ...opts
        };
      }
      walker(entry, opts, then) {
        new _Walker(this.walkerOpt(entry, opts)).on("done", then).start();
      }
      filterEntry(entry, partial) {
        let included = true;
        if (this.parent && this.parent.filterEntry) {
          var pt = this.basename + "/" + entry;
          included = this.parent.filterEntry(pt, partial);
        }
        this.ignoreFiles.forEach((f) => {
          if (this.ignoreRules[f]) {
            this.ignoreRules[f].forEach((rule) => {
              if (rule.negate !== included) {
                const match = rule.match("/" + entry) || rule.match(entry) || !!partial && (rule.match("/" + entry + "/") || rule.match(entry + "/")) || !!partial && rule.negate && (rule.match("/" + entry, true) || rule.match(entry, true));
                if (match) {
                  included = rule.negate;
                }
              }
            });
          }
        });
        return included;
      }
    };
    var WalkerSync = class _WalkerSync extends Walker {
      start() {
        this.onReaddir(fs2.readdirSync(this.path));
        return this;
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        this.onReadIgnoreFile(file, fs2.readFileSync(ig, "utf8"), then);
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        let st = fs2.lstatSync(abs);
        const isSymbolicLink = st.isSymbolicLink();
        if (this.follow && isSymbolicLink) {
          st = fs2.statSync(abs);
        }
        this.onstat({ st, entry, file, dir, isSymbolicLink }, then);
      }
      walker(entry, opts, then) {
        new _WalkerSync(this.walkerOpt(entry, opts)).start();
        then();
      }
    };
    var walk = (opts, callback) => {
      const p = new Promise((resolve, reject) => {
        new Walker(opts).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (opts) => new WalkerSync(opts).start().result;
    module2.exports = walk;
    walk.sync = walkSync;
    walk.Walker = Walker;
    walk.WalkerSync = WalkerSync;
  }
});
var require_lib4 = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/npm-packlist@5.1.3/node_modules/npm-packlist/lib/index.js"(exports, module2) {
    "use strict";
    var bundleWalk = require_lib2();
    var BundleWalker = bundleWalk.BundleWalker;
    var ignoreWalk = require_lib3();
    var IgnoreWalker = ignoreWalk.Walker;
    var rootBuiltinRules = Symbol("root-builtin-rules");
    var packageNecessaryRules = Symbol("package-necessary-rules");
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    var normalizePackageBin = require_lib();
    var packageMustHaveFileNames = "readme|copying|license|licence";
    var packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`;
    var packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\..*[^~$])?$`, "i");
    var fs2 = (0, import_chunk_OQQ4P4PG.__require)("fs");
    var glob = (0, import_chunk_W4B2MEEJ.require_glob)();
    var globify = (pattern) => pattern.split("\\").join("/");
    var readOutOfTreeIgnoreFiles = (root, rel, result = "") => {
      for (const file of [".npmignore", ".gitignore"]) {
        try {
          const ignoreContent = fs2.readFileSync(path2.join(root, file), { encoding: "utf8" });
          result += ignoreContent + "\n";
          break;
        } catch (err) {
          if (err.code !== "ENOENT") {
            throw err;
          }
        }
      }
      if (!rel) {
        return result;
      }
      const firstRel = rel.split(path2.sep)[0];
      const newRoot = path2.join(root, firstRel);
      const newRel = path2.relative(newRoot, path2.join(root, rel));
      return readOutOfTreeIgnoreFiles(newRoot, newRel, result);
    };
    var pathHasPkg = (input) => {
      if (!input.startsWith("node_modules/")) {
        return false;
      }
      const segments = input.slice("node_modules/".length).split("/", 2);
      return segments[0].startsWith("@") ? segments.length === 2 : true;
    };
    var pkgFromPath = (input) => {
      const segments = input.slice("node_modules/".length).split("/", 2);
      return segments[0].startsWith("@") ? segments.join("/") : segments[0];
    };
    var defaultRules = [
      ".npmignore",
      ".gitignore",
      "**/.git",
      "**/.svn",
      "**/.hg",
      "**/CVS",
      "**/.git/**",
      "**/.svn/**",
      "**/.hg/**",
      "**/CVS/**",
      "/.lock-wscript",
      "/.wafpickle-*",
      "/build/config.gypi",
      "npm-debug.log",
      "**/.npmrc",
      ".*.swp",
      ".DS_Store",
      "**/.DS_Store/**",
      "._*",
      "**/._*/**",
      "*.orig",
      "/package-lock.json",
      "/yarn.lock",
      "/pnpm-lock.yaml",
      "/archived-packages/**"
    ];
    var nameIsBadForWindows = (file) => /\*/.test(file);
    var Walker = class _Walker extends IgnoreWalker {
      constructor(opt) {
        opt = opt || {};
        opt.ignoreFiles = [
          rootBuiltinRules,
          "package.json",
          ".npmignore",
          ".gitignore",
          packageNecessaryRules
        ];
        opt.includeEmpty = false;
        opt.path = opt.path || process.cwd();
        const followRe = /^(?:\/node_modules\/(?:@[^/]+\/[^/]+|[^/]+)\/)*\/node_modules(?:\/@[^/]+)?$/;
        const rootPath = opt.parent ? opt.parent.root : opt.path;
        const followTestPath = opt.path.replace(/\\/g, "/").slice(rootPath.length);
        opt.follow = followRe.test(followTestPath);
        super(opt);
        if (this.isProject) {
          this.bundled = opt.bundled || [];
          this.bundledScopes = Array.from(new Set(
            this.bundled.filter((f) => /^@/.test(f)).map((f) => f.split("/")[0])
          ));
          this.packageJsonCache = this.parent ? this.parent.packageJsonCache : opt.packageJsonCache || /* @__PURE__ */ new Map();
          let rules = defaultRules.join("\n") + "\n";
          if (opt.prefix && opt.workspaces) {
            const gPath = globify(opt.path);
            const gPrefix = globify(opt.prefix);
            const gWorkspaces = opt.workspaces.map((ws) => globify(ws));
            if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {
              const relpath = path2.relative(opt.prefix, path2.dirname(opt.path));
              rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath);
            } else if (gPath === gPrefix) {
              rules += opt.workspaces.map((ws) => globify(path2.relative(opt.path, ws))).join("\n");
            }
          }
          super.onReadIgnoreFile(rootBuiltinRules, rules, (_) => _);
        } else {
          this.bundled = [];
          this.bundledScopes = [];
          this.packageJsonCache = this.parent.packageJsonCache;
        }
      }
      get isProject() {
        return !this.parent || this.parent.follow && this.isSymbolicLink;
      }
      onReaddir(entries) {
        if (this.isProject) {
          entries = entries.filter(
            (e) => e !== ".git" && !(e === "node_modules" && this.bundled.length === 0)
          );
        }
        if (!this.isProject || !entries.includes("package.json")) {
          return super.onReaddir(entries);
        }
        const ig = path2.resolve(this.path, "package.json");
        if (this.packageJsonCache.has(ig)) {
          const pkg = this.packageJsonCache.get(ig);
          if (!pkg || typeof pkg !== "object") {
            return this.readPackageJson(entries);
          }
          return this.getPackageFiles(entries, JSON.stringify(pkg));
        }
        this.readPackageJson(entries);
      }
      onReadPackageJson(entries, er, pkg) {
        if (er) {
          this.emit("error", er);
        } else {
          this.getPackageFiles(entries, pkg);
        }
      }
      mustHaveFilesFromPackage(pkg) {
        const files = [];
        if (pkg.browser) {
          files.push("/" + pkg.browser);
        }
        if (pkg.main) {
          files.push("/" + pkg.main);
        }
        if (pkg.bin) {
          for (const key in pkg.bin) {
            files.push("/" + pkg.bin[key]);
          }
        }
        files.push(
          "/package.json",
          "/npm-shrinkwrap.json",
          "!/package-lock.json",
          packageMustHaves
        );
        return files;
      }
      getPackageFiles(entries, pkg) {
        try {
          pkg = normalizePackageBin(JSON.parse(pkg.toString()));
        } catch (er) {
          return super.onReaddir(entries);
        }
        const ig = path2.resolve(this.path, "package.json");
        this.packageJsonCache.set(ig, pkg);
        if (!Array.isArray(pkg.files)) {
          return super.onReaddir(entries);
        }
        pkg.files.push(...this.mustHaveFilesFromPackage(pkg));
        if ((pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes("node_modules")) {
          pkg.files.push("node_modules");
        }
        const patterns = Array.from(new Set(pkg.files)).reduce((set2, pattern) => {
          const excl = pattern.match(/^!+/);
          if (excl) {
            pattern = pattern.slice(excl[0].length);
          }
          pattern = pattern.replace(/^\.?\/+/, "");
          const negate = excl && excl[0].length % 2 === 1;
          set2.push({ pattern, negate });
          return set2;
        }, []);
        let n = patterns.length;
        const set = /* @__PURE__ */ new Set();
        const negates = /* @__PURE__ */ new Set();
        const results = [];
        const then = (pattern, negate, er, fileList, i) => {
          if (er) {
            return this.emit("error", er);
          }
          results[i] = { negate, fileList };
          if (--n === 0) {
            processResults(results);
          }
        };
        const processResults = (processed) => {
          for (const { negate, fileList } of processed) {
            if (negate) {
              fileList.forEach((f) => {
                f = f.replace(/\/+$/, "");
                set.delete(f);
                negates.add(f);
              });
            } else {
              fileList.forEach((f) => {
                f = f.replace(/\/+$/, "");
                set.add(f);
                negates.delete(f);
              });
            }
          }
          const list = Array.from(set);
          pkg.files = list.concat(Array.from(negates).map((f) => "!" + f));
          const rdResult = Array.from(new Set(
            list.map((f) => f.replace(/^\/+/, ""))
          ));
          super.onReaddir(rdResult);
        };
        patterns.forEach(({ pattern, negate }, i) => this.globFiles(pattern, (er, res) => then(pattern, negate, er, res, i)));
      }
      filterEntry(entry, partial) {
        const p = this.path.slice(this.root.length + 1);
        const { isProject } = this;
        const pkg = isProject && pathHasPkg(entry) ? pkgFromPath(entry) : null;
        const rootNM = isProject && entry === "node_modules";
        const rootPJ = isProject && entry === "package.json";
        return (
          // if we're in a bundled package, check with the parent.
          /^node_modules($|\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(
            this.basename + "/" + entry,
            partial
          ) : pkg ? this.bundled.indexOf(pkg) !== -1 || this.bundledScopes.indexOf(pkg) !== -1 : rootNM ? !!this.bundled.length : rootPJ ? true : packageMustHavesRE.test(entry) ? true : isProject && (entry === "npm-shrinkwrap.json" || entry === "package.json") ? true : isProject && entry === "package-lock.json" ? false : super.filterEntry(entry, partial)
        );
      }
      filterEntries() {
        if (this.ignoreRules[".npmignore"]) {
          this.ignoreRules[".gitignore"] = null;
        }
        this.filterEntries = super.filterEntries;
        super.filterEntries();
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        if (file === "package.json" && !this.isProject) {
          then();
        } else if (this.packageJsonCache.has(ig)) {
          this.onPackageJson(ig, this.packageJsonCache.get(ig), then);
        } else {
          super.addIgnoreFile(file, then);
        }
      }
      onPackageJson(ig, pkg, then) {
        this.packageJsonCache.set(ig, pkg);
        if (Array.isArray(pkg.files)) {
          super.onReadIgnoreFile("package.json", pkg.files.map(
            (f) => "!" + f
          ).join("\n") + "\n", then);
        } else {
          const rules = this.mustHaveFilesFromPackage(pkg).map((f) => `!${f}`);
          const data = rules.join("\n") + "\n";
          super.onReadIgnoreFile(packageNecessaryRules, data, then);
        }
      }
      // override parent stat function to completely skip any filenames
      // that will break windows entirely.
      // XXX(isaacs) Next major version should make this an error instead.
      stat({ entry, file, dir }, then) {
        if (nameIsBadForWindows(entry)) {
          then();
        } else {
          super.stat({ entry, file, dir }, then);
        }
      }
      // override parent onstat function to nix all symlinks, other than
      // those coming out of the followed bundled symlink deps
      onstat({ st, entry, file, dir, isSymbolicLink }, then) {
        if (st.isSymbolicLink()) {
          then();
        } else {
          super.onstat({ st, entry, file, dir, isSymbolicLink }, then);
        }
      }
      onReadIgnoreFile(file, data, then) {
        if (file === "package.json") {
          try {
            const ig = path2.resolve(this.path, file);
            this.onPackageJson(ig, JSON.parse(data), then);
          } catch (er) {
            then();
          }
        } else {
          super.onReadIgnoreFile(file, data, then);
        }
      }
      sort(a, b) {
        const exta = path2.extname(a).toLowerCase();
        const extb = path2.extname(b).toLowerCase();
        const basea = path2.basename(a).toLowerCase();
        const baseb = path2.basename(b).toLowerCase();
        return exta.localeCompare(extb, "en") || basea.localeCompare(baseb, "en") || a.localeCompare(b, "en");
      }
      globFiles(pattern, cb) {
        glob(globify(pattern), { dot: true, cwd: this.path, nocase: true }, cb);
      }
      readPackageJson(entries) {
        fs2.readFile(this.path + "/package.json", (er, pkg) => this.onReadPackageJson(entries, er, pkg));
      }
      walker(entry, opt, then) {
        new _Walker(this.walkerOpt(entry, opt)).on("done", then).start();
      }
    };
    var walk = (options, callback) => {
      options = options || {};
      const p = new Promise((resolve, reject) => {
        const bw = new BundleWalker(options);
        bw.on("done", (bundled) => {
          options.bundled = bundled;
          options.packageJsonCache = bw.packageJsonCache;
          new Walker(options).on("done", resolve).on("error", reject).start();
        });
        bw.start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    module2.exports = walk;
    walk.Walker = Walker;
  }
});
var require_crypto_random_string = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/crypto-random-string@2.0.0/node_modules/crypto-random-string/index.js"(exports, module2) {
    "use strict";
    var crypto = (0, import_chunk_OQQ4P4PG.__require)("crypto");
    module2.exports = (length) => {
      if (!Number.isFinite(length)) {
        throw new TypeError("Expected a finite number");
      }
      return crypto.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
    };
  }
});
var require_unique_string = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/unique-string@2.0.0/node_modules/unique-string/index.js"(exports, module2) {
    "use strict";
    var cryptoRandomString = require_crypto_random_string();
    module2.exports = () => cryptoRandomString(32);
  }
});
var require_is_path_cwd = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/is-path-cwd@2.2.0/node_modules/is-path-cwd/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    module2.exports = (path_) => {
      let cwd = process.cwd();
      path_ = path2.resolve(path_);
      if (process.platform === "win32") {
        cwd = cwd.toLowerCase();
        path_ = path_.toLowerCase();
      }
      return path_ === cwd;
    };
  }
});
var require_is_path_inside = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/is-path-inside@3.0.3/node_modules/is-path-inside/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    module2.exports = (childPath, parentPath) => {
      const relation = path2.relative(parentPath, childPath);
      return Boolean(
        relation && relation !== ".." && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath)
      );
    };
  }
});
var require_clean_stack = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js"(exports, module2) {
    "use strict";
    var os = (0, import_chunk_OQQ4P4PG.__require)("os");
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});
var require_aggregate_error = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js"(exports, module2) {
    "use strict";
    var indentString = (0, import_chunk_HM4TYOFK.require_indent_string)();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError;
  }
});
var require_p_map = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js"(exports, module2) {
    "use strict";
    var AggregateError = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject(new AggregateError(errors));
              } else {
                resolve(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});
var require_del = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/del@6.1.1/node_modules/del/index.js"(exports, module2) {
    "use strict";
    var { promisify } = (0, import_chunk_OQQ4P4PG.__require)("util");
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    var globby = (0, import_chunk_MFGQSSGY.require_globby)();
    var isGlob = (0, import_chunk_MFGQSSGY.require_is_glob)();
    var slash = (0, import_chunk_MFGQSSGY.require_slash)();
    var gracefulFs = (0, import_chunk_6FFJQ4TS.require_graceful_fs)();
    var isPathCwd = require_is_path_cwd();
    var isPathInside = require_is_path_inside();
    var rimraf = (0, import_chunk_W4B2MEEJ.require_rimraf)();
    var pMap = require_p_map();
    var rimrafP = promisify(rimraf);
    var rimrafOptions = {
      glob: false,
      unlink: gracefulFs.unlink,
      unlinkSync: gracefulFs.unlinkSync,
      chmod: gracefulFs.chmod,
      chmodSync: gracefulFs.chmodSync,
      stat: gracefulFs.stat,
      statSync: gracefulFs.statSync,
      lstat: gracefulFs.lstat,
      lstatSync: gracefulFs.lstatSync,
      rmdir: gracefulFs.rmdir,
      rmdirSync: gracefulFs.rmdirSync,
      readdir: gracefulFs.readdir,
      readdirSync: gracefulFs.readdirSync
    };
    function safeCheck(file, cwd) {
      if (isPathCwd(file)) {
        throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
      }
      if (!isPathInside(file, cwd)) {
        throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
      }
    }
    function normalizePatterns(patterns) {
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      patterns = patterns.map((pattern) => {
        if (process.platform === "win32" && isGlob(pattern) === false) {
          return slash(pattern);
        }
        return pattern;
      });
      return patterns;
    }
    module2.exports = async (patterns, { force, dryRun, cwd = process.cwd(), onProgress = () => {
    }, ...options } = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
      if (files.length === 0) {
        onProgress({
          totalCount: 0,
          deletedCount: 0,
          percent: 1
        });
      }
      let deletedCount = 0;
      const mapper = async (file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          await rimrafP(file, rimrafOptions);
        }
        deletedCount += 1;
        onProgress({
          totalCount: files.length,
          deletedCount,
          percent: deletedCount / files.length
        });
        return file;
      };
      const removedFiles = await pMap(files, mapper, options);
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
    module2.exports.sync = (patterns, { force, dryRun, cwd = process.cwd(), ...options } = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
      const removedFiles = files.map((file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          rimraf.sync(file, rimrafOptions);
        }
        return file;
      });
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
  }
});
var require_tempy = (0, import_chunk_OQQ4P4PG.__commonJS)({
  "../../node_modules/.pnpm/tempy@1.0.1/node_modules/tempy/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_OQQ4P4PG.__require)("fs");
    var path2 = (0, import_chunk_OQQ4P4PG.__require)("path");
    var uniqueString = require_unique_string();
    var tempDir = (0, import_chunk_VWHCET2H.require_temp_dir)();
    var isStream = (0, import_chunk_IQB47LU2.require_is_stream)();
    var del = require_del();
    var stream = (0, import_chunk_OQQ4P4PG.__require)("stream");
    var { promisify } = (0, import_chunk_OQQ4P4PG.__require)("util");
    var pipeline = promisify(stream.pipeline);
    var { writeFile } = fs2.promises;
    var getPath = (prefix = "") => path2.join(tempDir, prefix + uniqueString());
    var writeStream = async (filePath, data) => pipeline(data, fs2.createWriteStream(filePath));
    var createTask = (tempyFunction, { extraArguments = 0 } = {}) => async (...arguments_) => {
      const [callback, options] = arguments_.slice(extraArguments);
      const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
      try {
        return await callback(result);
      } finally {
        await del(result, { force: true });
      }
    };
    module2.exports.file = (options) => {
      options = {
        ...options
      };
      if (options.name) {
        if (options.extension !== void 0 && options.extension !== null) {
          throw new Error("The `name` and `extension` options are mutually exclusive");
        }
        return path2.join(module2.exports.directory(), options.name);
      }
      return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
    };
    module2.exports.file.task = createTask(module2.exports.file);
    module2.exports.directory = ({ prefix = "" } = {}) => {
      const directory = getPath(prefix);
      fs2.mkdirSync(directory);
      return directory;
    };
    module2.exports.directory.task = createTask(module2.exports.directory);
    module2.exports.write = async (data, options) => {
      const filename = module2.exports.file(options);
      const write = isStream(data) ? writeStream : writeFile;
      await write(filename, data);
      return filename;
    };
    module2.exports.write.task = createTask(module2.exports.write, { extraArguments: 1 });
    module2.exports.writeSync = (data, options) => {
      const filename = module2.exports.file(options);
      fs2.writeFileSync(filename, data);
      return filename;
    };
    Object.defineProperty(module2.exports, "root", {
      get() {
        return tempDir;
      }
    });
  }
});
var import_npm_packlist = (0, import_chunk_OQQ4P4PG.__toESM)(require_lib4());
var import_read_pkg_up = (0, import_chunk_OQQ4P4PG.__toESM)((0, import_chunk_FGKIPLS5.require_read_pkg_up)());
var import_tempy = (0, import_chunk_OQQ4P4PG.__toESM)(require_tempy());
async function getPackedPackage(name, target, packageDir) {
  packageDir = packageDir || await (0, import_chunk_TCKAZCW5.resolvePkg)(name, { basedir: process.cwd() }) || await (0, import_chunk_TCKAZCW5.resolvePkg)(name, { basedir: target });
  if (!packageDir) {
    const pkg = import_read_pkg_up.default.sync({
      cwd: target
    });
    if (pkg && pkg.packageJson.name === name) {
      packageDir = import_path.default.dirname(pkg.path);
    }
  }
  if (!packageDir && import_fs.default.existsSync(import_path.default.join(process.cwd(), "package.json"))) {
    packageDir = process.cwd();
  }
  if (!packageDir) {
    throw new Error(`Error in getPackage: Could not resolve package ${name} from ${process.cwd()} target ${target}`);
  }
  const tmpDir = target ?? import_tempy.default.directory();
  const pkgFiles = await (0, import_npm_packlist.default)({ path: packageDir });
  for (const file of pkgFiles) {
    const src = import_path.default.join(packageDir, file);
    const dest = import_path.default.join(tmpDir, file);
    await import_fs.default.promises.mkdir(import_path.default.dirname(dest), { recursive: true });
    await import_fs.default.promises.copyFile(src, dest);
  }
  return import_path.default.join(tmpDir);
}
